# Всем привет, меня зовут Сиразетдинов Азат и тема моего доклада "Основа методов контейнеризации. Создание Docker контейнера." 

## Зачем нам контейнеризация?
- для изолированного запуска приложений и рабочих сред вне зависимости от системы и ПО, установленных на конкретной машине;
- контроля ресурсов и снижения нагрузки на систему;
- разрешения конфликтов, которые могут возникнуть из-за того, что разные приложения нуждаются в различных версиях ПО или библиотек;
- быстрого перемещения настроенных приложений и сред с одной машины на другую;

## Что такое контейнер?
Контейнер - это изолированный и ограниченный процесс.
Чтобы лучше понять это определение давайте посмотрим как операционная система Linux реализует это. А начнем мы с механизма контейнеризации namespaces.

## Chroot & clone
Зачатки контейнеризации появились в 1979 году с появлением системного вызова chroot. Все что он позволяет делать - изменить корневой каталог для одного процесса. Чтобы мы там смогли запускать консольные команды, нужно скопировать содержимое директории /bin/bash, вместе с библиотеками, в будущую корневую папку. Но этот системный вызов не позволяет изолировать и ограничивать процесс, чего мы хотим добиться от контейнеризации.
Из курса языков программирования, вспомним, что в Линуксе процессы организуют иерархическую структуру под названием "Дерево процессов". При загрузке системы появляется процесс с PID 1, от которого потом появляются все остальные процессы и службы. С появлением механизма namespaces появилась возможность создавать новые независимые деревья процессов, которые были бы изолированы друг от друга.
Для создания нового пространства имен PID используется системный вызов clone() с флагом CLONE_NEWPID. После клонирования у нас появится новый процесс, у которого PID будет равен 1.
Так же есть другие пространства имен, который нужно тоже изолировать, например NET. Для этого используются специальные флаги у команды clone, в данном случае CLONE_NEWNET. 
Чтобы обеспечить изолированность файловой системе используется создание пространства имен MOUNT с помощью флага CLONE_NEWNS.

## Cgroups
В итоге с помощью namespaces мы научились создавать изолированные процессы, но как правильно распоряжаться с ресурсами системы? Для этого умные люди придумали механизм под названием cgroups - control groups
Механизм состоит из двух простых частей - из ядра контрольной группы и 12 подсистем. Подсистемы занимаются управлением количества ресурсов системы, которые достаются процессору. Например, подсистема blkio устаналивает лимиты на чтение и запись в память, cpuset распределяет задачи между ядрами, cpuacct генерирует отчеты об использовании процессорного времени.

## Контейнеризация vs Виртуализация
Теперь мы узнали, что значат слова "изолированный" и "ограниченный" в определении контейнера. Теперь не составит труда ответить, в чем отличие контейнеризации от виртуализации. Виртуальная машина - полностью изолированная операционная система, которая включает в себя свое ядро, свои демоны и т.д., виртуальная машина потребляет все выделенные для нее ресурсы: она не умеет потреблять столько сколько требуется, а для изоляции используются механизмы железа. В свою очередь, контейнеризация работает на ядре хостовой операционной системы и использует для изоляции возможности не железа, а операционной системы.

## Runc
Перейдем к практической части. Чтобы запустить контейнер, нам было бы удобно использовать Container Runtime, который бы за нас сделал всю грязную работу по созданию контейнера, выделению для него пространства имен, и созданию контрольных групп. Рассмотрим, встроенный в Linux, базовый инструмент для запуска контейнеров - runc. 
Инструмент позовляет в конфигурационном файле указать все трубуемые параметры по ограничению ресурсов, переменных окружения. Под капотом он использует системный вызов fork для созданий процессов. Но пользоваться им на самом деле неудобно, потому что конфигурационный файл сложный, а так же runc не умеет создавать образы системы.

## Docker 
Теперь перейдем к теме моего доклада - система контейнеризации Docker. Для начала узнаем об основных понятиях:
Docker image (образ) – файл, в который упаковано приложение и его среда. Он содержит файловую систему, которая будет доступна приложению, и другие метаданные (например команды, которые должны быть выполнены при запуске контейнера).
Docker Container (контейнер) – это экземпляр образа. Выполняемый контейнер – это запущенный процесс, изолированный от других процессов на сервере и ограниченный выделенным объемом ресурсов.
Dockerfile - файл конфигурации докер контейнера, который мы сейчас и рассмотрим.

## Dockerfile
Dockerfile - последовательность команд которые будут выполнены докером при создании контейнера.
История начинается с команды FROM который указывает из какого образа мы будем собирать контейнер (образом как может являться операционная система (например Ubuntu), так и чужой образ, например готовый образ nginx)
Инструкция COPY позволяет скопировать директории с проектом в контейнер
Наша следующая комнада - RUN. Позволяет испольнить команду в консоли
CMD используется для указания отправной точки, которая будет исполнена чтобы запустить основной скрипт контейнера.
Каждая строчка в Dockerfile называется слоем, потому что docker умеет послойно кешировать контейнеры, что ускоряет запуск и уменьшает время создания контейнера при его пересоздании.
Осталось наш контейнер только запустить
docker build -t mycontainer . - соберет образ
docker run flask - запустит наш образ в контейнере

## Volumes & Networks
Это все удобно, но что если нам захочется запустить базу данных, или сервер в контейнере? 
Все данные, содержащиеся в контейнере удалятся при удаление контейнера, поэтому существуют механизм docker volumes, решающий проблему - он позволяет выделить общий для всех контейнеров участок в памяти, который мы сможем смонитировать к нашему контейнеру с базой данных. Его содержимое не удалится при удаление контейнера.
Похожую манипуляцию нужно сделать, чтобы модифицировать NET пространство имен, например для проброса портов. Для этого используется команда networks если мы хотим объеденить разные контейнеры одной сетью, или флаг -p если мы хотим реализовать доступ к порту контейнера извне(например вебсервер).

## Docker-compose
Говоря о docker, нельзя не упомянуть механизм docker-compose. Подробное рассмотрение этой темы останется за пределами доклада, но на слайде представлен синтаксис конфигурационного compose.yaml файла, в котором описываются все операции которые мы сегодндя обсуждали.

## Вопрос
Мой вопрос к экзамену - что такое контейнеризация и чем она отличается от виртуализации? Что такое Dockerfile, Docker Image, Docker Container и как из одного получить другое?



